   1 0000               # File:		solve.asm
   2 0000               # Author:	Margaret Dorsey
   3 0000               #
   4 0000               # Description:	solve.asm contains the functions directly involved in the
   5 0000               #		backtracking algorithm.
   6 0000               #
   7 0000               # Revisions:	see gitlog.txt
   8 0000               #
   9 0000               
  10 0000               #
  11 0000               # CONSTANT DEFINITIONS
  12 0000               #
  13 0000               
  14 0000               
  15 0000               #
  16 0000               # DATA BLOCK
  17 0000               #
  18 0000               	.data
  19 0000               	.align 2
  20 0000               
  21 0000               
  22 0000               #
  23 0000               # FUNCTIONS
  24 0000               #
  25 0000               
  26 0000               	.text
  27 0000               	.align 2
  28 0000               	
  29 0000               	.globl 	step_back
  30 0000               	.globl	step_forward
  31 0000               	.globl 	solve
  32 0000               
  33 0000               #
  34 0000               # Name:		solve
  35 0000               # 
  36 0000               # Description:	solve is the main loop driving the backtracking algorithm
  37 0000               #		it calls auxiliary functions and the stack functions until
  38 0000               #		a solution is found. Square values are changed in this function
  39 0000               #
  40 0000               # Arguments:	a0: pointer to board to solve
  41 0000               #		a1: dimension of the board
  42 0000               #
  43 0000               # Returns:	Nothing
  44 0000               #
  45 0000               
  46 0000               solve:
  47 0000 23BDFFF0		addi	$sp, $sp, -16
  48 0004 AFBF0000		sw	$ra, 0($sp)
  49 0008 AFB00004		sw	$s0, 4($sp)
  50 000c AFB10008		sw	$s1, 8($sp)
  51 0010 AFB2000C		sw	$s2, 12($sp)
  52 0014               
  53 0014 00808025		or	$s0, $a0, $zero	#keep our args
  54 0018 00A08825		or	$s1, $a1, $zero
  55 001c               	
  56 001c 340C0001		ori	$t4, $zero, 1	#for comparisons and setting
  57 0020 340D0002		ori	$t5, $zero, 2	
  58 0024               
  59 0024 0C000016		jal	set_next_square	#get our next square
  60 0028               solve_loop:
  61 0028 10400006		beq	$v0, $zero, solve_done
  62 002c 00409025		or	$s2, $v0, $zero	#store our new tile
  63 0030               	
  64 0030 AE4C0000		sw	$t4, 0($s2)	#make it white	
  65 0034               
  66 0034 02002025		or	$a0, $s0, $zero	#set up our args
  67 0038 02202825		or	$a1, $s1, $zero	
  68 003c 0C000016		jal	set_next_square	#get our next tile
  69 0040 0800000A		j	solve_loop
  70 0044               solve_done:
  71 0044 8FBF0000		lw 	$ra, 0($sp)	#restore stack and return
  72 0048 8FB00004		lw	$s0, 4($sp)
  73 004c 8FB20008		lw	$s2, 8($sp)
  74 0050 23BD0010		addi	$sp, $sp, 16
  75 0054 03E00008		jr	$ra		
  76 0058               #
  77 0058               # Name:		set_next_square
  78 0058               #
  79 0058               # Description:	Finds the next blank square in the puzzle and returns its index
  80 0058               #		or 0 if all the tiles are filled (and thus puzzle is complete)
  81 0058               #
  82 0058               # Arguments:	a0: pointer to board to solve
  83 0058               #		a1: dimension of the board
  84 0058               #
  85 0058               # Returns:	address of next blank tile or -1 if puzzle has no more blanks
  86 0058               #
  87 0058               
  88 0058               set_next_square:
  89 0058               					#no stack for leaf function
  90 0058               
  91 0058 00A50018		mult	$a1, $a1		#get the boundary addr for end of array
  92 005c 00004012		mflo	$t0
  93 0060 00084080		sll	$t0, 2
  94 0064 00884020		add	$t0, $a0, $t0
  95 0068               	
  96 0068 00001025		or	$v0, $zero, $zero	#null ptr until we find one
  97 006c               next_square_loop:
  98 006c 0088482A		slt	$t1, $a0, $t0		#less than boundary of array
  99 0070 11200006		beq	$t1, $zero, next_loop_done
 100 0074               	
 101 0074 8C8A0000		lw	$t2, 0($a0)		#get our tile
 102 0078 15400002		bne	$t2, $zero, non_zero	#is it blank?
 103 007c 00041025		or	$v0, $zero, $a0		#return our address
 104 0080 03E00008		jr	$ra				
 105 0084               non_zero:
 106 0084 20840004		add	$a0, $a0, 4		#next word in array
 107 0088 0800001B		j	next_square_loop
 108 008c               next_loop_done:
 109 008c 03E00008		jr	$ra			#return 0, puzzle done
 110 0090               #
 111 0090               # Name: 	check_column
 112 0090               #
 113 0090               # Description:	Checks the nth column of the board for compliance with the rules
 114 0090               #		of the puzzle.
 115 0090               #
 116 0090               # Arguments:	a0: pointer to board to solve
 117 0090               #		a1: dimension of the board
 118 0090               #		a2: index of column to check
 119 0090               #
 120 0090               # Returns:	0 on no error in column, 1 on error
 121 0090               #
 122 0090               
 123 0090               check_column:
 124 0090               					#no stack for leaf function
 125 0090               	
 126 0090 00C42020		add	$a0, $a2, $a0		#set up at our first tile to check
 127 0094 00A50018		mult	$a1, $a1
 128 0098 00004012		mflo	$t0			#get nxn or length of array
 129 009c 00084080		sll	$t0, 2			#multiply by 4 for word
 130 00a0 00884020		add	$t0, $a0, $t0		#get end boundary of the array
 131 00a4 00052880		sll	$a1, 2			#for incrementing earlier need words
 132 00a8               
 133 00a8 00004825		or	$t1, $zero, $zero	#set up our black counter
 134 00ac 00005025		or	$t2, $zero, $zero	#set up our white counter
 135 00b0 00005825		or	$t3, $zero, $zero	#set up our consecutive counter
 136 00b4 340CFFFF		ori	$t4, $zero, -1		#set up our previous color for
 137 00b8               					#checking consecutivity
 138 00b8               
 139 00b8 340F0001		ori	$t7, $zero, 1		#for comparison
 140 00bc 34180002		ori	$t8, $zero, 2		
 141 00c0               
 142 00c0               col_loop:
 143 00c0 0088682A		slt	$t5, $a0, $t0		#are we still on the board?
 144 00c4 11A0000E		beq	$t5, $zero, col_loop_done
 145 00c8               	
 146 00c8 8C8E0000		lw	$t6, 0($a0)		#get our tile
 147 00cc               
 148 00cc 11CC0001		beq	$t6, $t4, col_consec	#check for consecutivity
 149 00d0 00005825		or	$t3, $zero, $zero
 150 00d4               col_consec:
 151 00d4 11C00001		beq	$t6, $zero, col_cmp_1	#blank tiles don't count
 152 00d8 216B0001		addi	$t3, $t3, 1
 153 00dc               col_cmp_1:
 154 00dc 15CF0002		bne	$t6, $t7, col_cmp_2	#is it white?
 155 00e0 21290001		addi	$t1, $t1, 1
 156 00e4 0800003C		j	col_next
 157 00e8               col_cmp_2:
 158 00e8 15D80001		bne	$t6, $t8, col_next	#is it black?
 159 00ec 214A0001		addi	$t2, $t2, 1
 160 00f0               col_next:
 161 00f0 296D0003		slti	$t5, $t3, 3		#do we have 3 in a row?
 162 00f4 11A00008		beq	$t5, $zero, col_return_false
 163 00f8 00852020		add	$a0, $a0, $a1		#go to same column in next row
 164 00fc 08000030		j 	col_loop		#back to top of loop
 165 0100               col_loop_done:	
 166 0100 292D0004		slti	$t5, $t1, 4		#do we have too many whites?
 167 0104 11A00004		beq	$t5, $zero, col_return_false
 168 0108               
 169 0108 294D0004		slti	$t5, $t2, 4		#too many blacks?
 170 010c 11A00002		beq	$t5, $zero, col_return_false
 171 0110               	
 172 0110 00001025		or	$v0, $zero, $zero	
 173 0114 03E00008		jr 	$ra			#return	true
 174 0118               col_return_false:
 175 0118 34020001		ori	$v0, $zero, 1
 176 011c 03E00008		jr	$ra			#return false
 177 0120               
 178 0120               #
 179 0120               # Name:		check_row
 180 0120               #
 181 0120               # Description:	Checks the nth row of the board for compliance with the rules
 182 0120               #		of the puzzle
 183 0120               #
 184 0120               # Arguments:	a0: pointer to board to solve
 185 0120               #		a1: dimension of the board
 186 0120               #		a2: index of column to check
 187 0120               #
 188 0120               # Returns:	0 on no error in row, 1 on error
 189 0120               #
 190 0120               
 191 0120               check_row:
 192 0120               
 193 0120               					#no stack for leaf function
 194 0120 00A60018		mult	$a1, $a2		#get a ptr to the beginning of our row
 195 0124 00004012		mflo	$t0
 196 0128 00084080		sll	$t0, 2			#bytes
 197 012c 01042020		add	$a0, $t0, $a0	
 198 0130               	
 199 0130 01054020		add	$t0, $t0, $a1		#get boundary of our row
 200 0134               	
 201 0134 00004825		or	$t1, $zero, $zero	#set up our black counter
 202 0138 00005025		or	$t2, $zero, $zero	#set up our white counter
 203 013c 00005825		or	$t3, $zero, $zero	#set up our consecutive counter
 204 0140 340CFFFF		ori	$t4, $zero, -1		#set up our previous color for checking
 205 0144               					#consecutivity
 206 0144               	
 207 0144 340F0001		ori	$t7, $zero, 1		#for comparison
 208 0148 34180002		ori	$t8, $zero, 2
 209 014c               
 210 014c               row_loop:
 211 014c 0088682A		slt	$t5, $a0, $t0		#are we still in our row?
 212 0150 11A0000E		beq	$t5, $zero, row_loop_done
 213 0154               
 214 0154 8C8E0000		lw	$t6, 0($a0)		#get our tile
 215 0158               	
 216 0158 11C00001		beq	$t6, $zero, row_consec	#check consecutivity
 217 015c 00005825		or	$t3, $zero, $zero
 218 0160               row_consec:
 219 0160 11C00001		beq	$t6,$zero, row_cmp_1	#blank tiles don't count
 220 0164 216B0001		addi	$t3, $t3, 1
 221 0168               row_cmp_1:
 222 0168 15CF0002		bne	$t6, $t7, row_cmp_2	#is it white?
 223 016c 21290001		addi	$t1, $t1, 1
 224 0170 0800005F		j	row_next
 225 0174               row_cmp_2:
 226 0174 15D80001		bne	$t6, $t8, row_next	#is it black?
 227 0178 214A0001		addi	$t2, $t2, 1
 228 017c               row_next:
 229 017c 296D0003		slti	$t5, $t3, 3		#do we have 3 in a row?
 230 0180 11A00008		beq	$t5, $zero, row_return_false
 231 0184 20840004		add	$a0, $a0, 4		#next element in row
 232 0188 08000053		j	row_loop
 233 018c               row_loop_done:
 234 018c 292D0004		slti	$t5, $t1, 4		#too many whites?
 235 0190 11A00004		beq	$t5, $zero, row_return_false
 236 0194               	
 237 0194 294D0004		slti	$t5, $t2, 4		#too many blacks?
 238 0198 11A00002		beq	$t5, $zero, row_return_false
 239 019c               
 240 019c 00001025		or	$v0, $zero, $zero
 241 01a0 03E00008		jr	$ra			#return true
 242 01a4               row_return_false:
 243 01a4 34020001		ori	$v0, $zero, 1
 244 01a8 03E00008		jr	$ra			#return false


check_column        00000090 R  text 
check_row           00000120 R  text 
col_cmp_1           000000DC R  text 
col_cmp_2           000000E8 R  text 
col_consec          000000D4 R  text 
col_loop            000000C0 R  text 
col_loop_done       00000100 R  text 
col_next            000000F0 R  text 
col_return_false    00000118 R  text 
next_loop_done      0000008C R  text 
next_square_loop    0000006C R  text 
non_zero            00000084 R  text 
row_cmp_1           00000168 R  text 
row_cmp_2           00000174 R  text 
row_consec          00000160 R  text 
row_loop            0000014C R  text 
row_loop_done       0000018C R  text 
row_next            0000017C R  text 
row_return_false    000001A4 R  text 
set_next_square     00000058 R  text 
solve               00000000 RG text 
solve_done          00000044 R  text 
solve_loop          00000028 R  text 
step_back           ******** XG
step_forward        ******** XG
