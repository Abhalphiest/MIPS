   1 0000               # File:		solve.asm
   2 0000               # Author:	Margaret Dorsey
   3 0000               #
   4 0000               # Description:	solve.asm contains the functions directly involved in the
   5 0000               #		backtracking algorithm.
   6 0000               #
   7 0000               # Revisions:	see gitlog.txt
   8 0000               #
   9 0000               
  10 0000               #
  11 0000               # CONSTANT DEFINITIONS
  12 0000               #
  13 0000               
  14 0000               #syscall
  15 0000               EXIT =			10
  16 0000               
  17 0000               #for printing
  18 0000               IMPOSSIBLE_PUZZLE = 	2
  19 0000               
  20 0000               #
  21 0000               # DATA BLOCK
  22 0000               #
  23 0000               	.data
  24 0000               	.align 	2
  25 0000               
  26 0000               
  27 0000               #
  28 0000               # FUNCTIONS
  29 0000               #
  30 0000               
  31 0000               	.text
  32 0000               	.align 	2
  33 0000               	
  34 0000               	.globl 	step_back
  35 0000               	.globl	step_forward
  36 0000               	.globl 	solve
  37 0000               	.globl	print_predef
  38 0000               #
  39 0000               # Name:		solve
  40 0000               # 
  41 0000               # Description:	solve is the main loop driving the backtracking algorithm
  42 0000               #		it calls auxiliary functions and the stack functions until
  43 0000               #		a solution is found. Square values are changed in this function
  44 0000               #
  45 0000               # Arguments:	a0: pointer to board to solve
  46 0000               #		a1: dimension of the board
  47 0000               #
  48 0000               # Returns:	Nothing
  49 0000               #
  50 0000               
  51 0000               solve:
  52 0000 23BDFFE8		addi	$sp, $sp, -24
  53 0004 AFBF0000		sw	$ra, 0($sp)
  54 0008 AFB00004		sw	$s0, 4($sp)
  55 000c AFB10008		sw	$s1, 8($sp)
  56 0010 AFB2000C		sw	$s2, 12($sp)
  57 0014 AFB30010		sw	$s3, 16($sp)
  58 0018 AFB40014		sw	$s4, 20($sp)
  59 001c               
  60 001c 00808025		or	$s0, $a0, $zero	#keep our args
  61 0020 00A08825		or	$s1, $a1, $zero
  62 0024               	
  63 0024 34130001		ori	$s3, $zero, 1	#for comparisons and setting
  64 0028 34140002		ori	$s4, $zero, 2	
  65 002c               	
  66 002c 0C000047		jal	check_board	#see if we even started correct
  67 0030 10400005		beq	$v0, $zero, init_valid
  68 0034 34040002		ori	$a0, $zero, IMPOSSIBLE_PUZZLE
  69 0038 0C000000		jal	print_predef
  70 003c 3402000A		ori	$v0, $zero, EXIT
  71 0040 0000000C		syscall			#force exit
  72 0044 0C000000		jal	print_predef
  73 0048               init_valid:
  74 0048 02002025		or	$a0, $s0, $zero
  75 004c 02202825		or	$a1, $s1, $zero
  76 0050 0C000039		jal	set_next_square	#get our next square
  77 0054               solve_loop:
  78 0054 1040001B		beq	$v0, $zero, solve_done
  79 0058 00409025		or	$s2, $v0, $zero	#store our new tile
  80 005c               	
  81 005c 8E4E0000		lw	$t6, 0($s2)
  82 0060 11D30006		beq	$t6, $s3, set_black
  83 0064 11D4000A		beq	$t6, $s4, solve_step_back
  84 0068 AE530000		sw	$s3, 0($s2)	#make it white
  85 006c               	
  86 006c 02002025		or	$a0, $s0, $zero #check the board for correctness
  87 0070 02202825		or	$a1, $s1, $zero	
  88 0074 0C000047		jal	check_board	#will be 0 if correct
  89 0078 1040000A		beq	$v0, $zero, new_correct
  90 007c               set_black:
  91 007c AE540000		sw	$s4, 0($s2)	#try black instead
  92 0080 02002025		or	$a0, $s0, $zero	#check for correctness
  93 0084 02202825		or	$a1, $s1, $zero
  94 0088 0C000047		jal	check_board
  95 008c 10400005		beq	$v0, $zero, new_correct
  96 0090               solve_step_back:
  97 0090 AE400000		sw	$zero, 0($s2)	#set to blank and step back
  98 0094 02002025		or	$a0, $s0, $zero
  99 0098 02202825		or	$a1, $s1, $zero
 100 009c 0C000000		jal	step_back
 101 00a0 08000015		j solve_loop
 102 00a4               new_correct:
 103 00a4 02002025		or	$a0, $s0, $zero	#we changed a tile
 104 00a8 02202825		or	$a1, $s1, $zero
 105 00ac 02403025		or	$a2, $s2, $zero
 106 00b0 0C000000		jal	step_forward
 107 00b4               
 108 00b4 02002025		or	$a0, $s0, $zero	#set up our args
 109 00b8 02202825		or	$a1, $s1, $zero	
 110 00bc 0C000039		jal	set_next_square	#get our next tile
 111 00c0 08000015		j	solve_loop
 112 00c4               solve_done:
 113 00c4 8FBF0000		lw 	$ra, 0($sp)	#restore stack and return
 114 00c8 8FB00004		lw	$s0, 4($sp)
 115 00cc 8FB10008		lw	$s1, 8($sp)
 116 00d0 8FB2000C		lw	$s2, 12($sp)
 117 00d4 8FB30010		lw	$s3, 16($sp)
 118 00d8 8FB40014		lw	$s4, 20($sp)
 119 00dc 23BD0018		addi	$sp, $sp, 24
 120 00e0 03E00008		jr	$ra		
 121 00e4               #
 122 00e4               # Name:		set_next_square
 123 00e4               #
 124 00e4               # Description:	Finds the next blank square in the puzzle and returns its index
 125 00e4               #		or 0 if all the tiles are filled (and thus puzzle is complete)
 126 00e4               #
 127 00e4               # Arguments:	a0: pointer to board to solve
 128 00e4               #		a1: dimension of the board
 129 00e4               #
 130 00e4               # Returns:	address of next blank tile or 0  if puzzle has no more blanks
 131 00e4               #
 132 00e4               
 133 00e4               set_next_square:
 134 00e4               					#no stack for leaf function
 135 00e4               
 136 00e4 00A50018		mult	$a1, $a1		#get the boundary addr for end of array
 137 00e8 00004012		mflo	$t0
 138 00ec 00084080		sll	$t0, 2
 139 00f0 00884020		add	$t0, $a0, $t0
 140 00f4               	
 141 00f4 00001025		or	$v0, $zero, $zero	#null ptr until we find one
 142 00f8               next_square_loop:
 143 00f8 0088482A		slt	$t1, $a0, $t0		#less than boundary of array
 144 00fc 11200006		beq	$t1, $zero, next_loop_done
 145 0100               	
 146 0100 8C8A0000		lw	$t2, 0($a0)		#get our tile
 147 0104 15400002		bne	$t2, $zero, non_zero	#is it blank?
 148 0108 00041025		or	$v0, $zero, $a0		#return our address
 149 010c 03E00008		jr	$ra				
 150 0110               non_zero:
 151 0110 20840004		add	$a0, $a0, 4		#next word in array
 152 0114 0800003E		j	next_square_loop
 153 0118               next_loop_done:
 154 0118 03E00008		jr	$ra			#return 0, puzzle done
 155 011c               
 156 011c               
 157 011c               
 158 011c               
 159 011c               
 160 011c               #
 161 011c               # Name:		check_board
 162 011c               #
 163 011c               # Description:	Uses check_column and check row to check the board for
 164 011c               #		correctness, to keep the solve function a little cleaner.
 165 011c               #
 166 011c               # Arguments	a0: pointer to board to check
 167 011c               #		a1: dimension of the board
 168 011c               #
 169 011c               # Returns:	0 on correct board, 1 on error
 170 011c               #
 171 011c               
 172 011c               check_board:
 173 011c 23BDFFF0		addi	$sp, $sp, -16		#set up our stack
 174 0120 AFBF0000		sw	$ra, 0($sp)
 175 0124 AFB00004		sw	$s0, 4($sp)
 176 0128 AFB10008		sw	$s1, 8($sp)
 177 012c AFB2000C		sw	$s2, 12($sp)
 178 0130               
 179 0130 00808025		or	$s0, $a0, $zero		#store our args
 180 0134 00A08825		or	$s1, $a1, $zero
 181 0138               
 182 0138 00009025		or	$s2, $zero, $zero	#loop control
 183 013c               
 184 013c               check_board_loop:
 185 013c 0251482A		slt	$t1, $s2, $s1		#loop through our whole dimension
 186 0140 1120000C		beq	$t1, $zero, check_board_done
 187 0144               
 188 0144 02002025		or	$a0, $s0, $zero		#set up args for row check
 189 0148 02202825		or	$a1, $s1, $zero
 190 014c 02403025		or	$a2, $s2, $zero
 191 0150               
 192 0150 0C000093		jal	check_row		#returns 0 for correct
 193 0154               
 194 0154 1440000E		bne	$v0, $zero, check_board_false 
 195 0158               	
 196 0158 02002025		or	$a0, $s0, $zero		#set up args for column check
 197 015c 02202825		or	$a1, $s1, $zero
 198 0160 02403025		or	$a2, $s2, $zero
 199 0164               
 200 0164 0C00006B		jal 	check_column		#returns zero for correct
 201 0168               	
 202 0168 14400009		bne	$v0, $zero, check_board_false
 203 016c               
 204 016c 22520001		addi	$s2, $s2, 1		#increment loop counter
 205 0170 0800004F		j	check_board_loop	#back to top
 206 0174               
 207 0174               check_board_done:
 208 0174 00001025		or	$v0, $zero, $zero
 209 0178 8FBF0000		lw	$ra, 0($sp)
 210 017c 8FB00004		lw	$s0, 4($sp)
 211 0180 8FB10008		lw	$s1, 8($sp)
 212 0184 8FB2000C		lw	$s2, 12($sp)
 213 0188 23BD0010		addi	$sp, $sp, 16
 214 018c 03E00008		jr	$ra			#return true
 215 0190               
 216 0190               check_board_false:
 217 0190 34020001		ori	$v0, $zero, 1
 218 0194 8FBF0000		lw	$ra, 0($sp)
 219 0198 8FB00004		lw	$s0, 4($sp)
 220 019c 8FB10008		lw	$s1, 8($sp)
 221 01a0 8FB2000C		lw	$s2, 12($sp)
 222 01a4 23BD0010		addi	$sp, $sp, 16
 223 01a8 03E00008		jr	$ra			#return false
 224 01ac               
 225 01ac               #
 226 01ac               # Name: 	check_column
 227 01ac               #
 228 01ac               # Description:	Checks the nth column of the board for compliance with the rules
 229 01ac               #		of the puzzle.
 230 01ac               #
 231 01ac               # Arguments:	a0: pointer to board to solve
 232 01ac               #		a1: dimension of the board
 233 01ac               #		a2: index of column to check
 234 01ac               #
 235 01ac               # Returns:	0 on no error in column, 1 on error
 236 01ac               #
 237 01ac               
 238 01ac               check_column:
 239 01ac               					#no stack for leaf function
 240 01ac 00063080		sll	$a2, 2			#get words	
 241 01b0 00A50018		mult	$a1, $a1
 242 01b4 00004012		mflo	$t0			#get nxn or length of array
 243 01b8 00084080		sll	$t0, 2			#multiply by 4 for word
 244 01bc 00884020		add	$t0, $a0, $t0		#get end boundary of the array
 245 01c0 00052880		sll	$a1, 2			#for incrementing later  need words
 246 01c4 00C42020		add	$a0, $a2, $a0		#set up at first column tile
 247 01c8               
 248 01c8 00004825		or	$t1, $zero, $zero	#set up our black counter
 249 01cc 00005025		or	$t2, $zero, $zero	#set up our white counter
 250 01d0 00005825		or	$t3, $zero, $zero	#set up our consecutive counter
 251 01d4 340CFFFF		ori	$t4, $zero, -1		#set up our previous color for
 252 01d8               					#checking consecutivity
 253 01d8               
 254 01d8 340F0001		ori	$t7, $zero, 1		#for comparison
 255 01dc 34180002		ori	$t8, $zero, 2		
 256 01e0               
 257 01e0               col_loop:
 258 01e0 0088682A		slt	$t5, $a0, $t0		#are we still on the board?
 259 01e4 11A0000F		beq	$t5, $zero, col_loop_done
 260 01e8               	
 261 01e8 8C8E0000		lw	$t6, 0($a0)		#get our tile
 262 01ec               
 263 01ec 11CC0001		beq	$t6, $t4, col_consec	#check for consecutivity
 264 01f0 00005825		or	$t3, $zero, $zero
 265 01f4               col_consec:
 266 01f4 11C00001		beq	$t6, $zero, col_cmp_1	#blank tiles don't count
 267 01f8 216B0001		addi	$t3, $t3, 1
 268 01fc               col_cmp_1:
 269 01fc 01C06025		or	$t4, $t6, $zero		#update our last used color
 270 0200 15CF0002		bne	$t6, $t7, col_cmp_2	#is it white?
 271 0204 21290001		addi	$t1, $t1, 1
 272 0208 08000085		j	col_next
 273 020c               col_cmp_2:
 274 020c 15D80001		bne	$t6, $t8, col_next	#is it black?
 275 0210 214A0001		addi	$t2, $t2, 1
 276 0214               col_next:
 277 0214 296D0003		slti	$t5, $t3, 3		#do we have 3 in a row?
 278 0218 11A0000A		beq	$t5, $zero, col_return_false
 279 021c 00852020		add	$a0, $a0, $a1		#go to same column in next row
 280 0220 08000078		j 	col_loop		#back to top of loop
 281 0224               col_loop_done:
 282 0224 000528C2		srl	$a1, 3			#to get dimension/2
 283 0228 20A50001		addi	$a1, $a1, 1	
 284 022c 0125682A		slt	$t5, $t1, $a1		#do we have too many whites?
 285 0230 11A00004		beq	$t5, $zero, col_return_false
 286 0234               
 287 0234 0145682A		slt	$t5, $t2, $a1		#too many blacks?
 288 0238 11A00002		beq	$t5, $zero, col_return_false
 289 023c               	
 290 023c 00001025		or	$v0, $zero, $zero	
 291 0240 03E00008		jr 	$ra			#return	true
 292 0244               col_return_false:
 293 0244 34020001		ori	$v0, $zero, 1
 294 0248 03E00008		jr	$ra			#return false
 295 024c               
 296 024c               #
 297 024c               # Name:		check_row
 298 024c               #
 299 024c               # Description:	Checks the nth row of the board for compliance with the rules
 300 024c               #		of the puzzle
 301 024c               #
 302 024c               # Arguments:	a0: pointer to board to solve
 303 024c               #		a1: dimension of the board
 304 024c               #		a2: index of column to check
 305 024c               #
 306 024c               # Returns:	0 on no error in row, 1 on error
 307 024c               #
 308 024c               
 309 024c               check_row:
 310 024c               
 311 024c               					#no stack for leaf function
 312 024c 00A60018		mult	$a1, $a2		#get a ptr to the beginning of our row
 313 0250 00004012		mflo	$t0
 314 0254 00084080		sll	$t0, 2			#bytes
 315 0258 01042020		add	$a0, $t0, $a0	
 316 025c 00A04825		or	$t1, $a1, $zero
 317 0260 00094880		sll	$t1, 2
 318 0264 00894020		add	$t0, $a0, $t1		#get boundary of our row
 319 0268               	
 320 0268 00004825		or	$t1, $zero, $zero	#set up our black counter
 321 026c 00005025		or	$t2, $zero, $zero	#set up our white counter
 322 0270 00005825		or	$t3, $zero, $zero	#set up our consecutive counter
 323 0274 00006025		or	$t4, $zero, $zero	#set up our previous color for checking
 324 0278               					#consecutivity
 325 0278               	
 326 0278 340F0001		ori	$t7, $zero, 1		#for comparison
 327 027c 34180002		ori	$t8, $zero, 2
 328 0280               
 329 0280               row_loop:
 330 0280 0088682A		slt	$t5, $a0, $t0		#are we still in our row?
 331 0284 11A0000F		beq	$t5, $zero, row_loop_done
 332 0288               
 333 0288 8C8E0000		lw	$t6, 0($a0)		#get our tile
 334 028c               	
 335 028c 11CC0001		beq	$t6, $t4, row_consec	#check consecutivity
 336 0290 00005825		or	$t3, $zero, $zero
 337 0294               row_consec:
 338 0294 11C00001		beq	$t6,$zero, row_cmp_1	#blank tiles don't count
 339 0298 216B0001		addi	$t3, $t3, 1
 340 029c               row_cmp_1:
 341 029c 01C06025		or	$t4, $t6, $zero		#update our last color
 342 02a0 15CF0002		bne	$t6, $t7, row_cmp_2	#is it white?
 343 02a4 21290001		addi	$t1, $t1, 1
 344 02a8 080000AD		j	row_next
 345 02ac               row_cmp_2:
 346 02ac 15D80001		bne	$t6, $t8, row_next	#is it black?
 347 02b0 214A0001		addi	$t2, $t2, 1
 348 02b4               row_next:
 349 02b4 296D0003		slti	$t5, $t3, 3		#do we have 3 in a row?
 350 02b8 11A0000A		beq	$t5, $zero, row_return_false
 351 02bc 20840004		add	$a0, $a0, 4		#next element in row
 352 02c0 080000A0		j	row_loop
 353 02c4               row_loop_done:
 354 02c4 00052842		srl	$a1, 1			#to get dimension/2
 355 02c8 20A50001		addi	$a1, $a1, 1
 356 02cc 0125682A		slt	$t5, $t1, $a1		#too many whites?
 357 02d0 11A00004		beq	$t5, $zero, row_return_false
 358 02d4               	
 359 02d4 0145682A		slt	$t5, $t2, $a1		#too many blacks?
 360 02d8 11A00002		beq	$t5, $zero, row_return_false
 361 02dc               
 362 02dc 00001025		or	$v0, $zero, $zero
 363 02e0 03E00008		jr	$ra			#return true
 364 02e4               row_return_false:
 365 02e4 34020001		ori	$v0, $zero, 1
 366 02e8 03E00008		jr	$ra			#return false
 367 02ec               


EXIT               = 0000000A   
IMPOSSIBLE_PUZZLE  = 00000002   
check_board          0000011C R  text 
check_board_done     00000174 R  text 
check_board_false    00000190 R  text 
check_board_loop     0000013C R  text 
check_column         000001AC R  text 
check_row            0000024C R  text 
col_cmp_1            000001FC R  text 
col_cmp_2            0000020C R  text 
col_consec           000001F4 R  text 
col_loop             000001E0 R  text 
col_loop_done        00000224 R  text 
col_next             00000214 R  text 
col_return_false     00000244 R  text 
init_valid           00000048 R  text 
new_correct          000000A4 R  text 
next_loop_done       00000118 R  text 
next_square_loop     000000F8 R  text 
non_zero             00000110 R  text 
print_predef         ******** XG
row_cmp_1            0000029C R  text 
row_cmp_2            000002AC R  text 
row_consec           00000294 R  text 
row_loop             00000280 R  text 
row_loop_done        000002C4 R  text 
row_next             000002B4 R  text 
row_return_false     000002E4 R  text 
set_black            0000007C R  text 
set_next_square      000000E4 R  text 
solve                00000000 RG text 
solve_done           000000C4 R  text 
solve_loop           00000054 R  text 
solve_step_back      00000090 R  text 
step_back            ******** XG
step_forward         ******** XG
