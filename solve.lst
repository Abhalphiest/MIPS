   1 0000               # File:		solve.asm
   2 0000               # Author:	Margaret Dorsey
   3 0000               #
   4 0000               # Description:	solve.asm contains the functions directly involved in the
   5 0000               #		backtracking algorithm.
   6 0000               #
   7 0000               # Revisions:	see gitlog.txt
   8 0000               #
   9 0000               
  10 0000               #
  11 0000               # CONSTANT DEFINITIONS
  12 0000               #
  13 0000               
  14 0000               #syscall
  15 0000               EXIT =			10
  16 0000               
  17 0000               #for printing
  18 0000               IMPOSSIBLE_PUZZLE = 	2
  19 0000               
  20 0000               #
  21 0000               # DATA BLOCK
  22 0000               #
  23 0000               	.data
  24 0000               	.align 	2
  25 0000               
  26 0000               
  27 0000               #
  28 0000               # FUNCTIONS
  29 0000               #
  30 0000               
  31 0000               	.text
  32 0000               	.align 	2
  33 0000               	
  34 0000               	.globl 	step_back
  35 0000               	.globl	step_forward
  36 0000               	.globl 	solve
  37 0000               	.globl	print_predef
  38 0000               #
  39 0000               # Name:		solve
  40 0000               # 
  41 0000               # Description:	solve is the main loop driving the backtracking algorithm
  42 0000               #		it calls auxiliary functions and the stack functions until
  43 0000               #		a solution is found. Square values are changed in this function
  44 0000               #
  45 0000               # Arguments:	a0: pointer to board to solve
  46 0000               #		a1: dimension of the board
  47 0000               #
  48 0000               # Returns:	Nothing
  49 0000               #
  50 0000               
  51 0000               solve:
  52 0000 23BDFFE8		addi	$sp, $sp, -24
  53 0004 AFBF0000		sw	$ra, 0($sp)
  54 0008 AFB00004		sw	$s0, 4($sp)
  55 000c AFB10008		sw	$s1, 8($sp)
  56 0010 AFB2000C		sw	$s2, 12($sp)
  57 0014 AFB30010		sw	$s3, 16($sp)
  58 0018 AFB40014		sw	$s4, 20($sp)
  59 001c               
  60 001c 00808025		or	$s0, $a0, $zero	#keep our args
  61 0020 00A08825		or	$s1, $a1, $zero
  62 0024               	
  63 0024 34130001		ori	$s3, $zero, 1	#for comparisons and setting
  64 0028 34140002		ori	$s4, $zero, 2	
  65 002c               	
  66 002c 0C00002B		jal	check_board	#see if we even started correct
  67 0030 10400005		beq	$v0, $zero, init_valid
  68 0034 34040002		ori	$a0, $zero, IMPOSSIBLE_PUZZLE
  69 0038 0C000000		jal	print_predef
  70 003c 3402000A		ori	$v0, $zero, EXIT
  71 0040 0000000C		syscall			#force exit
  72 0044 0C000000		jal	print_predef
  73 0048               init_valid:
  74 0048 02002025		or	$a0, $s0, $zero
  75 004c 02202825		or	$a1, $s1, $zero
  76 0050 0C00001D		jal	set_next_square	#get our next square
  77 0054               #solve_loop:
  78 0054               #	beq	$v0, $zero, solve_done
  79 0054               #	or	$s2, $v0, $zero	#store our new tile
  80 0054               #	
  81 0054               #	lw	$t6, 0($s2)
  82 0054               #	beq	$t6, $s3, set_black
  83 0054               #	beq	$t6, $s4, solve_step_back
  84 0054               #	sw	$s3, 0($s2)	#make it white
  85 0054               #	
  86 0054               #	or	$a0, $s0, $zero #check the board for correctness
  87 0054               #	or	$a1, $s1, $zero	
  88 0054               #	jal	check_board	#will be 0 if correct
  89 0054               #	beq	$v0, $zero, new_correct
  90 0054               #set_black:
  91 0054               #	sw	$s4, 0($s2)	#try black instead
  92 0054               #	or	$a0, $s0, $zero	#check for correctness
  93 0054               #	or	$a1, $s1, $zero
  94 0054               #	jal	check_board
  95 0054               #	beq	$v0, $zero, new_correct
  96 0054               #solve_step_back:
  97 0054               #	sw	$zero, 0($s2)	#set to blank and step back
  98 0054               #	or	$a0, $s0, $zero
  99 0054               #	or	$a1, $s1, $zero
 100 0054               #	jal	step_back
 101 0054               #	j solve_loop
 102 0054               #new_correct:
 103 0054               #	or	$a0, $s0, $zero	#we changed a tile
 104 0054               #	or	$a1, $s1, $zero
 105 0054               #	or	$a2, $s2, $zero
 106 0054               #	jal	step_forward
 107 0054               #
 108 0054               #	or	$a0, $s0, $zero	#set up our args
 109 0054               #	or	$a1, $s1, $zero	
 110 0054               #	jal	set_next_square	#get our next tile
 111 0054               #	j	solve_loop
 112 0054               solve_done:
 113 0054 8FBF0000		lw 	$ra, 0($sp)	#restore stack and return
 114 0058 8FB00004		lw	$s0, 4($sp)
 115 005c 8FB10008		lw	$s1, 8($sp)
 116 0060 8FB2000C		lw	$s2, 12($sp)
 117 0064 8FB30010		lw	$s3, 16($sp)
 118 0068 8FB40014		lw	$s4, 20($sp)
 119 006c 23BD0018		addi	$sp, $sp, 24
 120 0070 03E00008		jr	$ra		
 121 0074               #
 122 0074               # Name:		set_next_square
 123 0074               #
 124 0074               # Description:	Finds the next blank square in the puzzle and returns its index
 125 0074               #		or 0 if all the tiles are filled (and thus puzzle is complete)
 126 0074               #
 127 0074               # Arguments:	a0: pointer to board to solve
 128 0074               #		a1: dimension of the board
 129 0074               #
 130 0074               # Returns:	address of next blank tile or 0  if puzzle has no more blanks
 131 0074               #
 132 0074               
 133 0074               set_next_square:
 134 0074               					#no stack for leaf function
 135 0074               
 136 0074 00A50018		mult	$a1, $a1		#get the boundary addr for end of array
 137 0078 00004012		mflo	$t0
 138 007c 00084080		sll	$t0, 2
 139 0080 00884020		add	$t0, $a0, $t0
 140 0084               	
 141 0084 00001025		or	$v0, $zero, $zero	#null ptr until we find one
 142 0088               next_square_loop:
 143 0088 0088482A		slt	$t1, $a0, $t0		#less than boundary of array
 144 008c 11200006		beq	$t1, $zero, next_loop_done
 145 0090               	
 146 0090 8C8A0000		lw	$t2, 0($a0)		#get our tile
 147 0094 15400002		bne	$t2, $zero, non_zero	#is it blank?
 148 0098 00041025		or	$v0, $zero, $a0		#return our address
 149 009c 03E00008		jr	$ra				
 150 00a0               non_zero:
 151 00a0 20840004		add	$a0, $a0, 4		#next word in array
 152 00a4 08000022		j	next_square_loop
 153 00a8               next_loop_done:
 154 00a8 03E00008		jr	$ra			#return 0, puzzle done
 155 00ac               
 156 00ac               
 157 00ac               
 158 00ac               
 159 00ac               
 160 00ac               #
 161 00ac               # Name:		check_board
 162 00ac               #
 163 00ac               # Description:	Uses check_column and check row to check the board for
 164 00ac               #		correctness, to keep the solve function a little cleaner.
 165 00ac               #
 166 00ac               # Arguments	a0: pointer to board to check
 167 00ac               #		a1: dimension of the board
 168 00ac               #
 169 00ac               # Returns:	0 on correct board, 1 on error
 170 00ac               #
 171 00ac               
 172 00ac               check_board:
 173 00ac 23BDFFF0		addi	$sp, $sp, -16		#set up our stack
 174 00b0 AFBF0000		sw	$ra, 0($sp)
 175 00b4 AFB00004		sw	$s0, 4($sp)
 176 00b8 AFB10008		sw	$s1, 8($sp)
 177 00bc AFB2000C		sw	$s2, 12($sp)
 178 00c0               
 179 00c0 00808025		or	$s0, $a0, $zero		#store our args
 180 00c4 00A08825		or	$s1, $a1, $zero
 181 00c8               
 182 00c8 00009025		or	$s2, $zero, $zero	#loop control
 183 00cc               
 184 00cc               check_board_loop:
 185 00cc 0251482A		slt	$t1, $s2, $s1		#loop through our whole dimension
 186 00d0 1120000C		beq	$t1, $zero, check_board_done
 187 00d4               
 188 00d4 02002025		or	$a0, $s0, $zero		#set up args for row check
 189 00d8 02202825		or	$a1, $s1, $zero
 190 00dc 02403025		or	$a2, $s2, $zero
 191 00e0               
 192 00e0 0C000077		jal	check_row		#returns 0 for correct
 193 00e4               
 194 00e4 1440000E		bne	$v0, $zero, check_board_false 
 195 00e8               	
 196 00e8 02002025		or	$a0, $s0, $zero		#set up args for column check
 197 00ec 02202825		or	$a1, $s1, $zero
 198 00f0 02403025		or	$a2, $s2, $zero
 199 00f4               
 200 00f4 0C00004F		jal 	check_column		#returns zero for correct
 201 00f8               	
 202 00f8 14400009		bne	$v0, $zero, check_board_false
 203 00fc               
 204 00fc 22520001		addi	$s2, $s2, 1		#increment loop counter
 205 0100 08000033		j	check_board_loop	#back to top
 206 0104               
 207 0104               check_board_done:
 208 0104 00001025		or	$v0, $zero, $zero
 209 0108 8FBF0000		lw	$ra, 0($sp)
 210 010c 8FB00004		lw	$s0, 4($sp)
 211 0110 8FB10008		lw	$s1, 8($sp)
 212 0114 8FB2000C		lw	$s2, 12($sp)
 213 0118 23BD0010		addi	$sp, $sp, 16
 214 011c 03E00008		jr	$ra			#return true
 215 0120               
 216 0120               check_board_false:
 217 0120 34020001		ori	$v0, $zero, 1
 218 0124 8FBF0000		lw	$ra, 0($sp)
 219 0128 8FB00004		lw	$s0, 4($sp)
 220 012c 8FB10008		lw	$s1, 8($sp)
 221 0130 8FB2000C		lw	$s2, 12($sp)
 222 0134 23BD0010		addi	$sp, $sp, 16
 223 0138 03E00008		jr	$ra			#return false
 224 013c               
 225 013c               #
 226 013c               # Name: 	check_column
 227 013c               #
 228 013c               # Description:	Checks the nth column of the board for compliance with the rules
 229 013c               #		of the puzzle.
 230 013c               #
 231 013c               # Arguments:	a0: pointer to board to solve
 232 013c               #		a1: dimension of the board
 233 013c               #		a2: index of column to check
 234 013c               #
 235 013c               # Returns:	0 on no error in column, 1 on error
 236 013c               #
 237 013c               
 238 013c               check_column:
 239 013c               					#no stack for leaf function
 240 013c 00063080		sll	$a2, 2			#get words	
 241 0140 00A50018		mult	$a1, $a1
 242 0144 00004012		mflo	$t0			#get nxn or length of array
 243 0148 00084080		sll	$t0, 2			#multiply by 4 for word
 244 014c 00884020		add	$t0, $a0, $t0		#get end boundary of the array
 245 0150 00052880		sll	$a1, 2			#for incrementing later  need words
 246 0154 00C42020		add	$a0, $a2, $a0		#set up at first column tile
 247 0158               
 248 0158 00004825		or	$t1, $zero, $zero	#set up our black counter
 249 015c 00005025		or	$t2, $zero, $zero	#set up our white counter
 250 0160 00005825		or	$t3, $zero, $zero	#set up our consecutive counter
 251 0164 340CFFFF		ori	$t4, $zero, -1		#set up our previous color for
 252 0168               					#checking consecutivity
 253 0168               
 254 0168 340F0001		ori	$t7, $zero, 1		#for comparison
 255 016c 34180002		ori	$t8, $zero, 2		
 256 0170               
 257 0170               col_loop:
 258 0170 0088682A		slt	$t5, $a0, $t0		#are we still on the board?
 259 0174 11A0000F		beq	$t5, $zero, col_loop_done
 260 0178               	
 261 0178 8C8E0000		lw	$t6, 0($a0)		#get our tile
 262 017c               
 263 017c 11CC0001		beq	$t6, $t4, col_consec	#check for consecutivity
 264 0180 00005825		or	$t3, $zero, $zero
 265 0184               col_consec:
 266 0184 11C00001		beq	$t6, $zero, col_cmp_1	#blank tiles don't count
 267 0188 216B0001		addi	$t3, $t3, 1
 268 018c               col_cmp_1:
 269 018c 01C06025		or	$t4, $t6, $zero		#update our last used color
 270 0190 15CF0002		bne	$t6, $t7, col_cmp_2	#is it white?
 271 0194 21290001		addi	$t1, $t1, 1
 272 0198 08000069		j	col_next
 273 019c               col_cmp_2:
 274 019c 15D80001		bne	$t6, $t8, col_next	#is it black?
 275 01a0 214A0001		addi	$t2, $t2, 1
 276 01a4               col_next:
 277 01a4 296D0003		slti	$t5, $t3, 3		#do we have 3 in a row?
 278 01a8 11A0000A		beq	$t5, $zero, col_return_false
 279 01ac 00852020		add	$a0, $a0, $a1		#go to same column in next row
 280 01b0 0800005C		j 	col_loop		#back to top of loop
 281 01b4               col_loop_done:
 282 01b4 000528C2		srl	$a1, 3			#to get dimension/2
 283 01b8 20A50001		addi	$a1, $a1, 1	
 284 01bc 0125682A		slt	$t5, $t1, $a1		#do we have too many whites?
 285 01c0 11A00004		beq	$t5, $zero, col_return_false
 286 01c4               
 287 01c4 0145682A		slt	$t5, $t2, $a1		#too many blacks?
 288 01c8 11A00002		beq	$t5, $zero, col_return_false
 289 01cc               	
 290 01cc 00001025		or	$v0, $zero, $zero	
 291 01d0 03E00008		jr 	$ra			#return	true
 292 01d4               col_return_false:
 293 01d4 34020001		ori	$v0, $zero, 1
 294 01d8 03E00008		jr	$ra			#return false
 295 01dc               
 296 01dc               #
 297 01dc               # Name:		check_row
 298 01dc               #
 299 01dc               # Description:	Checks the nth row of the board for compliance with the rules
 300 01dc               #		of the puzzle
 301 01dc               #
 302 01dc               # Arguments:	a0: pointer to board to solve
 303 01dc               #		a1: dimension of the board
 304 01dc               #		a2: index of column to check
 305 01dc               #
 306 01dc               # Returns:	0 on no error in row, 1 on error
 307 01dc               #
 308 01dc               
 309 01dc               check_row:
 310 01dc               
 311 01dc               					#no stack for leaf function
 312 01dc 00A60018		mult	$a1, $a2		#get a ptr to the beginning of our row
 313 01e0 00004012		mflo	$t0
 314 01e4 00084080		sll	$t0, 2			#bytes
 315 01e8 01042020		add	$a0, $t0, $a0	
 316 01ec 00A04825		or	$t1, $a1, $zero
 317 01f0 00094880		sll	$t1, 2
 318 01f4 00894020		add	$t0, $a0, $t1		#get boundary of our row
 319 01f8               	
 320 01f8 00004825		or	$t1, $zero, $zero	#set up our black counter
 321 01fc 00005025		or	$t2, $zero, $zero	#set up our white counter
 322 0200 00005825		or	$t3, $zero, $zero	#set up our consecutive counter
 323 0204 00006025		or	$t4, $zero, $zero	#set up our previous color for checking
 324 0208               					#consecutivity
 325 0208               	
 326 0208 340F0001		ori	$t7, $zero, 1		#for comparison
 327 020c 34180002		ori	$t8, $zero, 2
 328 0210               
 329 0210               row_loop:
 330 0210 0088682A		slt	$t5, $a0, $t0		#are we still in our row?
 331 0214 11A0000F		beq	$t5, $zero, row_loop_done
 332 0218               
 333 0218 8C8E0000		lw	$t6, 0($a0)		#get our tile
 334 021c               	
 335 021c 11CC0001		beq	$t6, $t4, row_consec	#check consecutivity
 336 0220 00005825		or	$t3, $zero, $zero
 337 0224               row_consec:
 338 0224 11C00001		beq	$t6,$zero, row_cmp_1	#blank tiles don't count
 339 0228 216B0001		addi	$t3, $t3, 1
 340 022c               row_cmp_1:
 341 022c 01C06025		or	$t4, $t6, $zero		#update our last color
 342 0230 15CF0002		bne	$t6, $t7, row_cmp_2	#is it white?
 343 0234 21290001		addi	$t1, $t1, 1
 344 0238 08000091		j	row_next
 345 023c               row_cmp_2:
 346 023c 15D80001		bne	$t6, $t8, row_next	#is it black?
 347 0240 214A0001		addi	$t2, $t2, 1
 348 0244               row_next:
 349 0244 296D0003		slti	$t5, $t3, 3		#do we have 3 in a row?
 350 0248 11A0000A		beq	$t5, $zero, row_return_false
 351 024c 20840004		add	$a0, $a0, 4		#next element in row
 352 0250 08000084		j	row_loop
 353 0254               row_loop_done:
 354 0254 00052842		srl	$a1, 1			#to get dimension/2
 355 0258 20A50001		addi	$a1, $a1, 1
 356 025c 0125682A		slt	$t5, $t1, $a1		#too many whites?
 357 0260 11A00004		beq	$t5, $zero, row_return_false
 358 0264               	
 359 0264 0145682A		slt	$t5, $t2, $a1		#too many blacks?
 360 0268 11A00002		beq	$t5, $zero, row_return_false
 361 026c               
 362 026c 00001025		or	$v0, $zero, $zero
 363 0270 03E00008		jr	$ra			#return true
 364 0274               row_return_false:
 365 0274 34020001		ori	$v0, $zero, 1
 366 0278 03E00008		jr	$ra			#return false
 367 027c               


EXIT               = 0000000A   
IMPOSSIBLE_PUZZLE  = 00000002   
check_board          000000AC R  text 
check_board_done     00000104 R  text 
check_board_false    00000120 R  text 
check_board_loop     000000CC R  text 
check_column         0000013C R  text 
check_row            000001DC R  text 
col_cmp_1            0000018C R  text 
col_cmp_2            0000019C R  text 
col_consec           00000184 R  text 
col_loop             00000170 R  text 
col_loop_done        000001B4 R  text 
col_next             000001A4 R  text 
col_return_false     000001D4 R  text 
init_valid           00000048 R  text 
next_loop_done       000000A8 R  text 
next_square_loop     00000088 R  text 
non_zero             000000A0 R  text 
print_predef         ******** XG
row_cmp_1            0000022C R  text 
row_cmp_2            0000023C R  text 
row_consec           00000224 R  text 
row_loop             00000210 R  text 
row_loop_done        00000254 R  text 
row_next             00000244 R  text 
row_return_false     00000274 R  text 
set_next_square      00000074 R  text 
solve                00000000 RG text 
solve_done           00000054 R  text 
step_back            ******** XG
step_forward         ******** XG
