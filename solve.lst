   1 0000               # File:		solve.asm
   2 0000               # Author:	Margaret Dorsey
   3 0000               #
   4 0000               # Description:	solve.asm contains the functions directly involved in the
   5 0000               #		backtracking algorithm.
   6 0000               #
   7 0000               # Revisions:	see gitlog.txt
   8 0000               #
   9 0000               
  10 0000               #
  11 0000               # CONSTANT DEFINITIONS
  12 0000               #
  13 0000               
  14 0000               #syscall
  15 0000               EXIT =			10
  16 0000               
  17 0000               #for printing
  18 0000               IMPOSSIBLE_PUZZLE = 	2
  19 0000               
  20 0000               #
  21 0000               # DATA BLOCK
  22 0000               #
  23 0000               	.data
  24 0000               	.align 	2
  25 0000               
  26 0000               
  27 0000               #
  28 0000               # FUNCTIONS
  29 0000               #
  30 0000               
  31 0000               	.text
  32 0000               	.align 	2
  33 0000               	
  34 0000               	.globl 	step_back
  35 0000               	.globl	step_forward
  36 0000               	.globl 	solve
  37 0000               	.globl	print_predef
  38 0000               #
  39 0000               # Name:		solve
  40 0000               # 
  41 0000               # Description:	solve is the main loop driving the backtracking algorithm
  42 0000               #		it calls auxiliary functions and the stack functions until
  43 0000               #		a solution is found. Square values are changed in this function
  44 0000               #
  45 0000               # Arguments:	a0: pointer to board to solve
  46 0000               #		a1: dimension of the board
  47 0000               #
  48 0000               # Returns:	Nothing
  49 0000               #
  50 0000               
  51 0000               solve:
  52 0000 23BDFFE8		addi	$sp, $sp, -24
  53 0004 AFBF0000		sw	$ra, 0($sp)
  54 0008 AFB00004		sw	$s0, 4($sp)
  55 000c AFB10008		sw	$s1, 8($sp)
  56 0010 AFB2000C		sw	$s2, 12($sp)
  57 0014 AFB30010		sw	$s3, 16($sp)
  58 0018 AFB40014		sw	$s4, 20($sp)
  59 001c               
  60 001c 00808025		or	$s0, $a0, $zero	#keep our args
  61 0020 00A08825		or	$s1, $a1, $zero
  62 0024               	
  63 0024 34130001		ori	$s3, $zero, 1	#for comparisons and setting
  64 0028 34140002		ori	$s4, $zero, 2	
  65 002c               	
  66 002c 0C000044		jal	check_board	#see if we even started correct
  67 0030 10400005		beq	$v0, $zero, init_valid
  68 0034 34040002		ori	$a0, $zero, IMPOSSIBLE_PUZZLE
  69 0038 0C000000		jal	print_predef
  70 003c 3402000A		ori	$v0, $zero, EXIT
  71 0040 0000000C		syscall			#force exit
  72 0044 0C000000		jal	print_predef
  73 0048               init_valid:
  74 0048 02002025		or	$a0, $s0, $zero
  75 004c 02202825		or	$a1, $s1, $zero
  76 0050 0C000036		jal	set_next_square	#get our next square
  77 0054               solve_loop:
  78 0054 10400018		beq	$v0, $zero, solve_done
  79 0058 00409025		or	$s2, $v0, $zero	#store our new tile
  80 005c               	
  81 005c 8E4E0000		lw	$t6, 0($s2)
  82 0060 11D30006		beq	$t6, $s3, set_black
  83 0064 11D4000A		beq	$t6, $s4, solve_step_back
  84 0068 AE530000		sw	$s3, 0($s2)	#make it white
  85 006c               	
  86 006c 02002025		or	$a0, $s0, $zero #check the board for correctness
  87 0070 02202825		or	$a1, $s1, $zero	
  88 0074 0C000044		jal	check_board	#will be 0 if correct
  89 0078 10400009		beq	$v0, $zero, new_correct
  90 007c               set_black:
  91 007c AE540000		sw	$s4, 0($s2)	#try black instead
  92 0080 02002025		or	$a0, $s0, $zero	#check for correctness
  93 0084 02202825		or	$a1, $s1, $zero
  94 0088 0C000044		jal	check_board
  95 008c 10400004		beq	$v0, $zero, new_correct
  96 0090               solve_step_back:
  97 0090 AE400000		sw	$zero, 0($s2)	#set to blank and step back
  98 0094 02402025		or	$a0, $s2, $zero
  99 0098 0C000000		jal	step_back
 100 009c 08000015		j 	solve_loop
 101 00a0               new_correct:
 102 00a0 02402025		or	$a0, $s2, $zero	#we changed a tile
 103 00a4 0C000000		jal	step_forward
 104 00a8               
 105 00a8 02002025		or	$a0, $s0, $zero	#set up our args
 106 00ac 02202825		or	$a1, $s1, $zero	
 107 00b0 0C000036		jal	set_next_square	#get our next tile
 108 00b4 08000015		j	solve_loop
 109 00b8               solve_done:
 110 00b8 8FBF0000		lw 	$ra, 0($sp)	#restore stack and return
 111 00bc 8FB00004		lw	$s0, 4($sp)
 112 00c0 8FB10008		lw	$s1, 8($sp)
 113 00c4 8FB2000C		lw	$s2, 12($sp)
 114 00c8 8FB30010		lw	$s3, 16($sp)
 115 00cc 8FB40014		lw	$s4, 20($sp)
 116 00d0 23BD0018		addi	$sp, $sp, 24
 117 00d4 03E00008		jr	$ra		
 118 00d8               #
 119 00d8               # Name:		set_next_square
 120 00d8               #
 121 00d8               # Description:	Finds the next blank square in the puzzle and returns its index
 122 00d8               #		or 0 if all the tiles are filled (and thus puzzle is complete)
 123 00d8               #
 124 00d8               # Arguments:	a0: pointer to board to solve
 125 00d8               #		a1: dimension of the board
 126 00d8               #
 127 00d8               # Returns:	address of next blank tile or 0  if puzzle has no more blanks
 128 00d8               #
 129 00d8               
 130 00d8               set_next_square:
 131 00d8               					#no stack for leaf function
 132 00d8               
 133 00d8 00A50018		mult	$a1, $a1		#get the boundary addr for end of array
 134 00dc 00004012		mflo	$t0
 135 00e0 00084080		sll	$t0, 2
 136 00e4 00884020		add	$t0, $a0, $t0
 137 00e8               	
 138 00e8 00001025		or	$v0, $zero, $zero	#null ptr until we find one
 139 00ec               next_square_loop:
 140 00ec 0088482A		slt	$t1, $a0, $t0		#less than boundary of array
 141 00f0 11200006		beq	$t1, $zero, next_loop_done
 142 00f4               	
 143 00f4 8C8A0000		lw	$t2, 0($a0)		#get our tile
 144 00f8 15400002		bne	$t2, $zero, non_zero	#is it blank?
 145 00fc 00041025		or	$v0, $zero, $a0		#return our address
 146 0100 03E00008		jr	$ra				
 147 0104               non_zero:
 148 0104 20840004		add	$a0, $a0, 4		#next word in array
 149 0108 0800003B		j	next_square_loop
 150 010c               next_loop_done:
 151 010c 03E00008		jr	$ra			#return 0, puzzle done
 152 0110               
 153 0110               
 154 0110               
 155 0110               
 156 0110               
 157 0110               #
 158 0110               # Name:		check_board
 159 0110               #
 160 0110               # Description:	Uses check_column and check row to check the board for
 161 0110               #		correctness, to keep the solve function a little cleaner.
 162 0110               #
 163 0110               # Arguments	a0: pointer to board to check
 164 0110               #		a1: dimension of the board
 165 0110               #
 166 0110               # Returns:	0 on correct board, 1 on error
 167 0110               #
 168 0110               
 169 0110               check_board:
 170 0110 23BDFFF0		addi	$sp, $sp, -16		#set up our stack
 171 0114 AFBF0000		sw	$ra, 0($sp)
 172 0118 AFB00004		sw	$s0, 4($sp)
 173 011c AFB10008		sw	$s1, 8($sp)
 174 0120 AFB2000C		sw	$s2, 12($sp)
 175 0124               
 176 0124 00808025		or	$s0, $a0, $zero		#store our args
 177 0128 00A08825		or	$s1, $a1, $zero
 178 012c               
 179 012c 00009025		or	$s2, $zero, $zero	#loop control
 180 0130               
 181 0130               check_board_loop:
 182 0130 0251482A		slt	$t1, $s2, $s1		#loop through our whole dimension
 183 0134 1120000C		beq	$t1, $zero, check_board_done
 184 0138               
 185 0138 02002025		or	$a0, $s0, $zero		#set up args for row check
 186 013c 02202825		or	$a1, $s1, $zero
 187 0140 02403025		or	$a2, $s2, $zero
 188 0144               
 189 0144 0C000090		jal	check_row		#returns 0 for correct
 190 0148               
 191 0148 1440000E		bne	$v0, $zero, check_board_false 
 192 014c               	
 193 014c 02002025		or	$a0, $s0, $zero		#set up args for column check
 194 0150 02202825		or	$a1, $s1, $zero
 195 0154 02403025		or	$a2, $s2, $zero
 196 0158               
 197 0158 0C000068		jal 	check_column		#returns zero for correct
 198 015c               	
 199 015c 14400009		bne	$v0, $zero, check_board_false
 200 0160               
 201 0160 22520001		addi	$s2, $s2, 1		#increment loop counter
 202 0164 0800004C		j	check_board_loop	#back to top
 203 0168               
 204 0168               check_board_done:
 205 0168 00001025		or	$v0, $zero, $zero
 206 016c 8FBF0000		lw	$ra, 0($sp)
 207 0170 8FB00004		lw	$s0, 4($sp)
 208 0174 8FB10008		lw	$s1, 8($sp)
 209 0178 8FB2000C		lw	$s2, 12($sp)
 210 017c 23BD0010		addi	$sp, $sp, 16
 211 0180 03E00008		jr	$ra			#return true
 212 0184               
 213 0184               check_board_false:
 214 0184 34020001		ori	$v0, $zero, 1
 215 0188 8FBF0000		lw	$ra, 0($sp)
 216 018c 8FB00004		lw	$s0, 4($sp)
 217 0190 8FB10008		lw	$s1, 8($sp)
 218 0194 8FB2000C		lw	$s2, 12($sp)
 219 0198 23BD0010		addi	$sp, $sp, 16
 220 019c 03E00008		jr	$ra			#return false
 221 01a0               
 222 01a0               #
 223 01a0               # Name: 	check_column
 224 01a0               #
 225 01a0               # Description:	Checks the nth column of the board for compliance with the rules
 226 01a0               #		of the puzzle.
 227 01a0               #
 228 01a0               # Arguments:	a0: pointer to board to solve
 229 01a0               #		a1: dimension of the board
 230 01a0               #		a2: index of column to check
 231 01a0               #
 232 01a0               # Returns:	0 on no error in column, 1 on error
 233 01a0               #
 234 01a0               
 235 01a0               check_column:
 236 01a0               					#no stack for leaf function
 237 01a0 00063080		sll	$a2, 2			#get words	
 238 01a4 00A50018		mult	$a1, $a1
 239 01a8 00004012		mflo	$t0			#get nxn or length of array
 240 01ac 00084080		sll	$t0, 2			#multiply by 4 for word
 241 01b0 00884020		add	$t0, $a0, $t0		#get end boundary of the array
 242 01b4 00052880		sll	$a1, 2			#for incrementing later  need words
 243 01b8 00C42020		add	$a0, $a2, $a0		#set up at first column tile
 244 01bc               
 245 01bc 00004825		or	$t1, $zero, $zero	#set up our black counter
 246 01c0 00005025		or	$t2, $zero, $zero	#set up our white counter
 247 01c4 00005825		or	$t3, $zero, $zero	#set up our consecutive counter
 248 01c8 340CFFFF		ori	$t4, $zero, -1		#set up our previous color for
 249 01cc               					#checking consecutivity
 250 01cc               
 251 01cc 340F0001		ori	$t7, $zero, 1		#for comparison
 252 01d0 34180002		ori	$t8, $zero, 2		
 253 01d4               
 254 01d4               col_loop:
 255 01d4 0088682A		slt	$t5, $a0, $t0		#are we still on the board?
 256 01d8 11A0000F		beq	$t5, $zero, col_loop_done
 257 01dc               	
 258 01dc 8C8E0000		lw	$t6, 0($a0)		#get our tile
 259 01e0               
 260 01e0 11CC0001		beq	$t6, $t4, col_consec	#check for consecutivity
 261 01e4 00005825		or	$t3, $zero, $zero
 262 01e8               col_consec:
 263 01e8 11C00001		beq	$t6, $zero, col_cmp_1	#blank tiles don't count
 264 01ec 216B0001		addi	$t3, $t3, 1
 265 01f0               col_cmp_1:
 266 01f0 01C06025		or	$t4, $t6, $zero		#update our last used color
 267 01f4 15CF0002		bne	$t6, $t7, col_cmp_2	#is it white?
 268 01f8 21290001		addi	$t1, $t1, 1
 269 01fc 08000082		j	col_next
 270 0200               col_cmp_2:
 271 0200 15D80001		bne	$t6, $t8, col_next	#is it black?
 272 0204 214A0001		addi	$t2, $t2, 1
 273 0208               col_next:
 274 0208 296D0003		slti	$t5, $t3, 3		#do we have 3 in a row?
 275 020c 11A0000A		beq	$t5, $zero, col_return_false
 276 0210 00852020		add	$a0, $a0, $a1		#go to same column in next row
 277 0214 08000075		j 	col_loop		#back to top of loop
 278 0218               col_loop_done:
 279 0218 000528C2		srl	$a1, 3			#to get dimension/2
 280 021c 20A50001		addi	$a1, $a1, 1	
 281 0220 0125682A		slt	$t5, $t1, $a1		#do we have too many whites?
 282 0224 11A00004		beq	$t5, $zero, col_return_false
 283 0228               
 284 0228 0145682A		slt	$t5, $t2, $a1		#too many blacks?
 285 022c 11A00002		beq	$t5, $zero, col_return_false
 286 0230               	
 287 0230 00001025		or	$v0, $zero, $zero	
 288 0234 03E00008		jr 	$ra			#return	true
 289 0238               col_return_false:
 290 0238 34020001		ori	$v0, $zero, 1
 291 023c 03E00008		jr	$ra			#return false
 292 0240               
 293 0240               #
 294 0240               # Name:		check_row
 295 0240               #
 296 0240               # Description:	Checks the nth row of the board for compliance with the rules
 297 0240               #		of the puzzle
 298 0240               #
 299 0240               # Arguments:	a0: pointer to board to solve
 300 0240               #		a1: dimension of the board
 301 0240               #		a2: index of column to check
 302 0240               #
 303 0240               # Returns:	0 on no error in row, 1 on error
 304 0240               #
 305 0240               
 306 0240               check_row:
 307 0240               
 308 0240               					#no stack for leaf function
 309 0240 00A60018		mult	$a1, $a2		#get a ptr to the beginning of our row
 310 0244 00004012		mflo	$t0
 311 0248 00084080		sll	$t0, 2			#bytes
 312 024c 01042020		add	$a0, $t0, $a0	
 313 0250 00A04825		or	$t1, $a1, $zero
 314 0254 00094880		sll	$t1, 2
 315 0258 00894020		add	$t0, $a0, $t1		#get boundary of our row
 316 025c               	
 317 025c 00004825		or	$t1, $zero, $zero	#set up our black counter
 318 0260 00005025		or	$t2, $zero, $zero	#set up our white counter
 319 0264 00005825		or	$t3, $zero, $zero	#set up our consecutive counter
 320 0268 00006025		or	$t4, $zero, $zero	#set up our previous color for checking
 321 026c               					#consecutivity
 322 026c               	
 323 026c 340F0001		ori	$t7, $zero, 1		#for comparison
 324 0270 34180002		ori	$t8, $zero, 2
 325 0274               
 326 0274               row_loop:
 327 0274 0088682A		slt	$t5, $a0, $t0		#are we still in our row?
 328 0278 11A0000F		beq	$t5, $zero, row_loop_done
 329 027c               
 330 027c 8C8E0000		lw	$t6, 0($a0)		#get our tile
 331 0280               	
 332 0280 11CC0001		beq	$t6, $t4, row_consec	#check consecutivity
 333 0284 00005825		or	$t3, $zero, $zero
 334 0288               row_consec:
 335 0288 11C00001		beq	$t6,$zero, row_cmp_1	#blank tiles don't count
 336 028c 216B0001		addi	$t3, $t3, 1
 337 0290               row_cmp_1:
 338 0290 01C06025		or	$t4, $t6, $zero		#update our last color
 339 0294 15CF0002		bne	$t6, $t7, row_cmp_2	#is it white?
 340 0298 21290001		addi	$t1, $t1, 1
 341 029c 080000AA		j	row_next
 342 02a0               row_cmp_2:
 343 02a0 15D80001		bne	$t6, $t8, row_next	#is it black?
 344 02a4 214A0001		addi	$t2, $t2, 1
 345 02a8               row_next:
 346 02a8 296D0003		slti	$t5, $t3, 3		#do we have 3 in a row?
 347 02ac 11A0000A		beq	$t5, $zero, row_return_false
 348 02b0 20840004		add	$a0, $a0, 4		#next element in row
 349 02b4 0800009D		j	row_loop
 350 02b8               row_loop_done:
 351 02b8 00052842		srl	$a1, 1			#to get dimension/2
 352 02bc 20A50001		addi	$a1, $a1, 1
 353 02c0 0125682A		slt	$t5, $t1, $a1		#too many whites?
 354 02c4 11A00004		beq	$t5, $zero, row_return_false
 355 02c8               	
 356 02c8 0145682A		slt	$t5, $t2, $a1		#too many blacks?
 357 02cc 11A00002		beq	$t5, $zero, row_return_false
 358 02d0               
 359 02d0 00001025		or	$v0, $zero, $zero
 360 02d4 03E00008		jr	$ra			#return true
 361 02d8               row_return_false:
 362 02d8 34020001		ori	$v0, $zero, 1
 363 02dc 03E00008		jr	$ra			#return false
 364 02e0               


EXIT               = 0000000A   
IMPOSSIBLE_PUZZLE  = 00000002   
check_board          00000110 R  text 
check_board_done     00000168 R  text 
check_board_false    00000184 R  text 
check_board_loop     00000130 R  text 
check_column         000001A0 R  text 
check_row            00000240 R  text 
col_cmp_1            000001F0 R  text 
col_cmp_2            00000200 R  text 
col_consec           000001E8 R  text 
col_loop             000001D4 R  text 
col_loop_done        00000218 R  text 
col_next             00000208 R  text 
col_return_false     00000238 R  text 
init_valid           00000048 R  text 
new_correct          000000A0 R  text 
next_loop_done       0000010C R  text 
next_square_loop     000000EC R  text 
non_zero             00000104 R  text 
print_predef         ******** XG
row_cmp_1            00000290 R  text 
row_cmp_2            000002A0 R  text 
row_consec           00000288 R  text 
row_loop             00000274 R  text 
row_loop_done        000002B8 R  text 
row_next             000002A8 R  text 
row_return_false     000002D8 R  text 
set_black            0000007C R  text 
set_next_square      000000D8 R  text 
solve                00000000 RG text 
solve_done           000000B8 R  text 
solve_loop           00000054 R  text 
solve_step_back      00000090 R  text 
step_back            ******** XG
step_forward         ******** XG
